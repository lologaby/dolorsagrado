---
import Layout from '../layouts/Layout.astro';

const gallery = [
  '/images/piercing-gallery-1.jpg',
  '/images/piercing-gallery-2.jpg',
  '/images/piercing-gallery-3.jpg',
  '/images/piercing-gallery-4.jpg',
  '/images/piercing-gallery-5.jpg',
  '/images/piercing-gallery-6.jpg',
];

/*
  3D Pieces — cada entry tiene:
    id:      slug único
    title:   nombre de la pieza
    style:   descripción del estilo
    model:   path al archivo .glb en /public/models/
    thumb:   imagen de preview (foto real del tatuaje)
    placeholder: true mientras no exista el .glb
*/
const pieces3d = [
  {
    id: 'sleeve-01',
    title: 'Sleeve Black & Grey',
    style: 'Full sleeve · Realismo oscuro',
    model: '/models/joshua-sleeve-01.glb',
    thumb: '/images/piercing-gallery-1.jpg',
    placeholder: true,
  },
  {
    id: 'forearm-02',
    title: 'Antebrazo Geométrico',
    style: 'Forearm · Blackwork + geometría',
    model: '/models/joshua-forearm-02.glb',
    thumb: '/images/piercing-gallery-2.jpg',
    placeholder: true,
  },
  {
    id: 'upper-arm-03',
    title: 'Brazo Superior · Retrato',
    style: 'Upper arm · Retrato Black & Grey',
    model: '/models/joshua-upper-arm-03.glb',
    thumb: '/images/piercing-gallery-3.jpg',
    placeholder: true,
  },
  {
    id: 'calf-04',
    title: 'Pantorrilla Floral',
    style: 'Calf · Botanical · Dotwork',
    model: '/models/joshua-calf-04.glb',
    thumb: '/images/piercing-gallery-4.jpg',
    placeholder: true,
  },
];
---

<Layout
  title="Joshua Reyes — Piezas 3D · Sacred Pain Tattoo"
  description="Explora las piezas de Joshua Reyes en 3D. Brazos modelados en Blender con sus tatuajes. Rota, examina, descubre el arte."
>
  <!-- ═══════════════════════════════════ HERO -->
  <section class="artist-hero">
    <div class="artist-hero-bg">
      <img src="/images/piercing-gallery-2.jpg" alt="" aria-hidden="true" />
      <div class="artist-hero-overlay"></div>
    </div>
    <div class="container artist-hero-content fade-in">
      <div class="artist-meta">
        <p class="kicker">Sacred Pain · San Juan, PR</p>
        <h1 class="h1">Joshua Reyes</h1>
        <p class="artist-specialty">Black &amp; Grey · Arte en la piel</p>
        <p class="artist-handle">
          <a href="https://www.instagram.com/jousoytuartista" target="_blank" rel="noreferrer">@jousoytuartista</a>
        </p>
        <div class="artist-ctas">
          <a class="btn btn-gold" href="/reservar">Reservar cita</a>
          <a class="btn btn-outline-gold" href="https://www.instagram.com/jousoytuartista" target="_blank" rel="noreferrer">Instagram</a>
        </div>
      </div>
    </div>
  </section>

  <!-- ═══════════════════════════════ 3D VIEWER SECTION -->
  <section class="section-3d" id="piezas-3d">
    <div class="container-3d">

      <!-- Section header -->
      <div class="s3d-header fade-in">
        <p class="kicker">Experiencia inmersiva</p>
        <h2 class="h2">Piezas en <span class="gold-text">3D</span></h2>
        <p class="lead s3d-lead">
          Cada tatuaje de Joshua modelado en Blender. Rota, acerca y examina
          cada detalle como si lo tuvieras en frente.
        </p>
        <div class="s3d-controls-hint">
          <span><svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 8v8M8 12h8"/></svg> Arrastrar · Rotar</span>
          <span><svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 3l-9 9M3 21l9-9M14 3h7v7M10 21H3v-7"/></svg> Pellizcar · Zoom</span>
          <span><svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3"/></svg> Click derecho · Pan</span>
        </div>
      </div>

      <!-- Piece selector tabs -->
      <div class="s3d-tabs fade-in" role="tablist" aria-label="Selecciona una pieza 3D">
        {pieces3d.map((p, i) => (
          <button
            class={`s3d-tab${i === 0 ? ' s3d-tab--active' : ''}`}
            role="tab"
            aria-selected={i === 0 ? 'true' : 'false'}
            data-piece={p.id}
            data-model={p.model}
            data-placeholder={p.placeholder ? 'true' : 'false'}
            aria-label={p.title}
          >
            <div class="s3d-tab-thumb">
              <img src={p.thumb} alt={p.title} loading="lazy" />
              <div class="s3d-tab-badge">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                3D
              </div>
            </div>
            <div class="s3d-tab-info">
              <span class="s3d-tab-title">{p.title}</span>
              <span class="s3d-tab-style">{p.style}</span>
            </div>
          </button>
        ))}
      </div>

      <!-- 3D Canvas -->
      <div class="s3d-viewer-wrap fade-in">
        <canvas id="canvas-3d" class="s3d-canvas" aria-label="Viewer 3D interactivo"></canvas>

        <!-- Loading overlay -->
        <div class="s3d-loading" id="s3d-loading">
          <div class="s3d-spinner"></div>
          <p>Cargando modelo 3D…</p>
        </div>

        <!-- Preview badge (while real .glb is pending) -->
        <div class="s3d-placeholder" id="s3d-placeholder">
          <div class="s3d-placeholder-inner">
            <p class="s3d-placeholder-title">
              <svg width="11" height="11" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
              Preview · Modelo final en Blender próximamente
            </p>
          </div>
        </div>

        <!-- Viewer UI overlay -->
        <div class="s3d-ui" id="s3d-ui">
          <div class="s3d-piece-name" id="s3d-piece-name"></div>
          <div class="s3d-actions">
            <button class="s3d-btn" id="btn-reset" title="Resetear cámara">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
            <button class="s3d-btn" id="btn-autorotate" title="Auto-rotación" class="active">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>
            </button>
            <button class="s3d-btn" id="btn-fullscreen" title="Pantalla completa">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
            </button>
          </div>
        </div>
      </div>

      <!-- CTA under viewer -->
      <div class="s3d-cta fade-in">
        <p class="s3d-cta-text">
          ¿Quieres un diseño personalizado de Joshua?
        </p>
        <a class="btn btn-gold" href="/reservar">Reservar con Joshua</a>
        <a class="btn" href="https://www.instagram.com/jousoytuartista" target="_blank" rel="noreferrer">Ver Instagram</a>
      </div>
    </div>
  </section>

  <hr class="divider" />

  <!-- ══════════════════════════════════════════════ BIO -->
  <section class="section">
    <div class="container bio-grid fade-in">
      <div>
        <p class="kicker">Sobre el artista</p>
        <h2 class="h2">Black &amp; Grey<br/>con carácter</h2>
      </div>
      <div class="bio-text">
        <p class="lead">
          Joshua Reyes es parte del equipo de Sacred Pain Tattoo.
          Su especialidad en <strong>Black &amp; Grey</strong> le permite crear piezas
          con alto contraste, texturas detalladas y una profundidad visual que marca la piel
          con intención y permanencia.
        </p>
        <p class="lead" style="margin-top:16px">
          Pionero en presentar su trabajo en formato 3D interactivo — cada pieza modelada en Blender
          para que puedas ver el tatuaje desde todos los ángulos antes de decidir.
        </p>
        <div style="margin-top:24px;display:flex;gap:10px;flex-wrap:wrap">
          <a class="btn btn-gold" href="/reservar">Reservar cita</a>
          <a class="btn btn-outline-gold" href="https://www.instagram.com/jousoytuartista" target="_blank" rel="noreferrer">Instagram</a>
        </div>
      </div>
    </div>
  </section>

  <hr class="divider" />

  <!-- ══════════════════════════════════════ GALERÍA FOTOS -->
  <section class="gallery-section">
    <div class="container fade-in" style="padding-bottom:32px">
      <p class="kicker">Portfolio fotográfico</p>
      <h2 class="h2">El arte de Joshua</h2>
    </div>
    <div class="artist-gallery-grid">
      {gallery.map((img, i) => (
        <a
          class={`ag-item${i === 0 ? ' ag-item--tall' : ''}`}
          href="https://www.instagram.com/jousoytuartista"
          target="_blank"
          rel="noreferrer"
          aria-label="Ver en Instagram"
        >
          <img src={img} alt="Tatuaje por Joshua Reyes" loading="lazy" />
          <div class="ag-overlay"><span>↗</span></div>
        </a>
      ))}
    </div>
    <div class="container" style="padding-top:28px;text-align:center">
      <a class="btn btn-outline-gold" href="https://www.instagram.com/jousoytuartista" target="_blank" rel="noreferrer">
        Ver portafolio completo en Instagram
      </a>
    </div>
  </section>

  <hr class="divider" />

  <!-- ═══════════════════════════ RESERVAR CTA -->
  <section class="section-sm">
    <div class="container">
      <div class="artist-cta-block card fade-in">
        <div>
          <p class="kicker">¿Listo para tu pieza?</p>
          <h2 class="h2">Reserva con Joshua</h2>
          <p class="lead">Cuéntanos tu idea y coordinamos la sesión.</p>
        </div>
        <div class="artist-cta-btns">
          <a class="btn btn-gold" href="/reservar">Reservar cita</a>
          <a class="btn" href="tel:7875962562">
            <svg width="15" height="15" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M22 16.92V20a2 2 0 0 1-2.18 2A19.79 19.79 0 0 1 4.37 6.18 2 2 0 0 1 6.36 4h3.08a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L10.91 11.4a16 16 0 0 0 6.69 6.69l.78-.78a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
            Llamar al estudio
          </a>
        </div>
      </div>
    </div>
  </section>

  <hr class="divider" />

  <!-- ═══════════════════════════ AFTERCARE -->
  <section class="section aftercare-section">
    <div class="container fade-in">
      <p class="kicker">Cuidado posterior</p>
      <h2 class="h2">Aftercare del tatuaje</h2>
      <p class="lead" style="margin-bottom:32px">
        El cuidado post-tatuaje es tan importante como la sesión misma.
      </p>
      <div class="aftercare-grid">
        <div class="aftercare-card card"><div class="card-body">
          <p class="aftercare-num">01</p>
          <h3 class="h3">Primeras 24 horas</h3>
          <p>Mantén el vendaje 2–4 horas. Lava con agua tibia y jabón sin fragancia.</p>
        </div></div>
        <div class="aftercare-card card"><div class="card-body">
          <p class="aftercare-num">02</p>
          <h3 class="h3">Días 2–7</h3>
          <p>Aplica Lubriderm o Aquaphor 2–3 veces al día. Evita remojar en agua.</p>
        </div></div>
        <div class="aftercare-card card"><div class="card-body">
          <p class="aftercare-num">03</p>
          <h3 class="h3">Semanas 2–4</h3>
          <p>No arranques la piel. Hidrata diario. Evita sol y piscina hasta sanar.</p>
        </div></div>
        <div class="aftercare-card card"><div class="card-body">
          <p class="aftercare-num">04</p>
          <h3 class="h3">Lo que debes evitar</h3>
          <p>Rascarte, sol directo, nadar, ropa ajustada, cremas con alcohol o fragancia.</p>
        </div></div>
      </div>
    </div>
  </section>
</Layout>

<!-- ─── Three.js UE5-style Viewer ────────────────────────────── -->
<script type="module">
/* ═══════════════════════════════════════════════════════════════
   UE5-STYLE 3D VIEWER — Three.js r167
   Features:
   · MeshPhysicalMaterial with subsurface-scattering approximation
   · 4096-px tattoo canvas textures with normal/roughness variation
   · Cinematic ACES filmic tone-map + auto-exposure simulation
   · Bokeh-style animated depth-of-field vignette (post quad)
   · Ambient particles (floating ink dust)
   · Volumetric rim-light lens flare sprite
   · High-res shadow maps + PCF-Soft
   · Animated environment-probe colour cycling (studio shift)
   · Smooth camera dolly-in on load
   ═══════════════════════════════════════════════════════════════ */

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader }    from 'https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader }   from 'https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/loaders/DRACOLoader.js';

/* ── DOM ─────────────────────────────────────────────────────── */
const canvas        = document.getElementById('canvas-3d');
const loadingEl     = document.getElementById('s3d-loading');
const placeholderEl = document.getElementById('s3d-placeholder');
const uiEl          = document.getElementById('s3d-ui');
const pieceNameEl   = document.getElementById('s3d-piece-name');
const btnReset      = document.getElementById('btn-reset');
const btnAuto       = document.getElementById('btn-autorotate');
const btnFS         = document.getElementById('btn-fullscreen');
const tabs          = document.querySelectorAll('.s3d-tab');
const wrap          = document.querySelector('.s3d-viewer-wrap');

/* ── Renderer ────────────────────────────────────────────────── */
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5));
renderer.outputColorSpace   = THREE.SRGBColorSpace;
renderer.shadowMap.enabled  = true;
renderer.shadowMap.type     = THREE.PCFSoftShadowMap;
renderer.toneMapping        = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.55;

const scene  = new THREE.Scene();
/* Deep cinematic black with a hint of warm smoke */
scene.background = new THREE.Color(0x080608);
scene.fog = new THREE.FogExp2(0x0c0a0e, 0.14);

const camera = new THREE.PerspectiveCamera(38, 1, 0.01, 60);
camera.position.set(0, 0.25, 3.2);

/* ── Environment (fake IBL via hemisphere) ───────────────────── */
/* Sky: warm studio tungsten  Ground: cold ambient bounce */
const hemi = new THREE.HemisphereLight(0xffe8c0, 0x1a1020, 0.45);
scene.add(hemi);

/* ── Key light — large soft-box, warm ───────────────────────── */
const key = new THREE.DirectionalLight(0xfff2d8, 3.6);
key.position.set(2.2, 4.0, 2.8);
key.castShadow = true;
key.shadow.mapSize.set(4096, 4096);
key.shadow.camera.near  = 0.3;
key.shadow.camera.far   = 18;
key.shadow.camera.left  = -2.5;
key.shadow.camera.right = 2.5;
key.shadow.camera.top   = 3;
key.shadow.camera.bottom= -3;
key.shadow.bias         = -0.0004;
key.shadow.radius       = 4;            // soft penumbra
scene.add(key);

/* ── Fill light — cool blue-grey, opposite ──────────────────── */
const fill = new THREE.DirectionalLight(0x7ab8d8, 0.65);
fill.position.set(-3, 1, 1.5);
scene.add(fill);

/* ── Rim / hair light — gold, behind ────────────────────────── */
const rim = new THREE.DirectionalLight(0xd4a03a, 1.4);
rim.position.set(0.4, -1.2, -3.2);
scene.add(rim);

/* ── Uplight — desaturated purple, subtle ───────────────────── */
const up = new THREE.PointLight(0x9060c0, 0.18, 7);
up.position.set(0, -1.8, 0.8);
scene.add(up);

/* ── Accent spot — punchy warm behind model ─────────────────── */
const spot = new THREE.SpotLight(0xff8833, 1.8, 10, Math.PI / 8, 0.6, 2);
spot.position.set(1.5, 2.5, -2.5);
spot.castShadow = true;
spot.shadow.mapSize.set(1024, 1024);
scene.add(spot);

/* ── Floor (reflective dark resin look) ─────────────────────── */
const floorMat = new THREE.MeshStandardMaterial({
  color:     0x0c0a10,
  roughness: 0.10,
  metalness: 0.85,
  envMapIntensity: 1.0,
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -1.12;
floor.receiveShadow = true;
scene.add(floor);

/* Thin grid on top of floor */
const grid = new THREE.GridHelper(8, 32, 0x1a1520, 0x131018);
grid.position.y = -1.11;
scene.add(grid);

/* ── Lens-flare sprite ───────────────────────────────────────── */
const flareCanvas = document.createElement('canvas');
flareCanvas.width = flareCanvas.height = 128;
const fc = flareCanvas.getContext('2d');
const fg = fc.createRadialGradient(64, 64, 0, 64, 64, 64);
fg.addColorStop(0,   'rgba(255,200,100,0.95)');
fg.addColorStop(0.2, 'rgba(255,150,50,0.45)');
fg.addColorStop(0.6, 'rgba(200,120,30,0.10)');
fg.addColorStop(1,   'rgba(0,0,0,0)');
fc.fillStyle = fg;
fc.fillRect(0, 0, 128, 128);
const flareTex = new THREE.CanvasTexture(flareCanvas);
const flareMat = new THREE.SpriteMaterial({ map: flareTex, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.35, depthWrite: false });
const flareSprite = new THREE.Sprite(flareMat);
flareSprite.scale.set(1.8, 1.8, 1);
flareSprite.position.set(2.2, 3.8, 2.8);
scene.add(flareSprite);

/* ── Ambient dust particles ──────────────────────────────────── */
const dustCount = 320;
const dustGeo   = new THREE.BufferGeometry();
const dustPos   = new Float32Array(dustCount * 3);
const dustSizes = new Float32Array(dustCount);
for (let i = 0; i < dustCount; i++) {
  dustPos[i*3]   = (Math.random() - 0.5) * 4;
  dustPos[i*3+1] = (Math.random() - 0.5) * 3;
  dustPos[i*3+2] = (Math.random() - 0.5) * 3;
  dustSizes[i]   = Math.random() * 3.5 + 0.8;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
dustGeo.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));
const dustMat = new THREE.PointsMaterial({
  color: 0xc8a870,
  size: 0.014,
  transparent: true,
  opacity: 0.30,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  sizeAttenuation: true,
});
const dustPoints = new THREE.Points(dustGeo, dustMat);
scene.add(dustPoints);

/* ── Vignette post quad ──────────────────────────────────────── */
const vigCanvas = document.createElement('canvas');
vigCanvas.width = vigCanvas.height = 256;
const vc  = vigCanvas.getContext('2d');
const vg  = vc.createRadialGradient(128, 128, 48, 128, 128, 182);
vg.addColorStop(0,   'rgba(0,0,0,0)');
vg.addColorStop(0.6, 'rgba(0,0,0,0)');
vg.addColorStop(1,   'rgba(0,0,0,0.82)');
vc.fillStyle = vg;
vc.fillRect(0, 0, 256, 256);
const vigTex = new THREE.CanvasTexture(vigCanvas);
const vigMat = new THREE.SpriteMaterial({ map: vigTex, transparent: true, opacity: 1.0, depthWrite: false, depthTest: false });
const vigSprite = new THREE.Sprite(vigMat);
vigSprite.renderOrder = 999;
const vigCam  = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
const vigScene = new THREE.Scene();
const vigGeo   = new THREE.PlaneGeometry(2, 2);
const vigMesh  = new THREE.Mesh(vigGeo, new THREE.MeshBasicMaterial({ map: vigTex, transparent: true, depthWrite: false, depthTest: false }));
vigScene.add(vigMesh);

/* ── OrbitControls ───────────────────────────────────────────── */
const controls = new OrbitControls(camera, canvas);
controls.enableDamping   = true;
controls.dampingFactor   = 0.045;
controls.minDistance     = 0.7;
controls.maxDistance     = 5.0;
controls.autoRotate      = true;
controls.autoRotateSpeed = 1.2;
controls.target.set(0, 0.05, 0);
controls.maxPolarAngle   = Math.PI * 0.78;

/* ── GLTF / DRACO ────────────────────────────────────────────── */
const draco = new DRACOLoader();
draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/libs/draco/');
const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(draco);

/* ══════════════════════════════════════════════════════════════
   UE5-STYLE SKIN MATERIAL
   MeshPhysicalMaterial approximates subsurface scattering via
   thickness + sheen + a warm specular colour.
   ══════════════════════════════════════════════════════════════ */
function makeSkinMat(color = 0x9a7055) {
  return new THREE.MeshPhysicalMaterial({
    color:             new THREE.Color(color),
    roughness:         0.68,
    metalness:         0.0,
    sheen:             0.55,
    sheenRoughness:    0.75,
    sheenColor:        new THREE.Color(0xff8060),
    /* Subsurface: multiply transmissive pink glow through thin geometry */
    transmission:      0.0,
    thickness:         0.12,
    attenuationColor:  new THREE.Color(0xff9970),
    attenuationDistance: 0.4,
    specularIntensity: 0.55,
    specularColor:     new THREE.Color(0xffe8d0),
    clearcoat:         0.08,
    clearcoatRoughness: 0.55,
  });
}

/* ══════════════════════════════════════════════════════════════
   PROCEDURAL ARM — high poly for UE5 silhouette quality
   ══════════════════════════════════════════════════════════════ */
function buildArm(tattooStyle = 0) {
  const group = new THREE.Group();
  const S = makeSkinMat;

  function limbSegment(rTop, rBot, height, y, mat) {
    const g = new THREE.Group();
    const cyl = new THREE.Mesh(new THREE.CylinderGeometry(rTop, rBot, height, 40, 6, false), mat.clone());
    cyl.castShadow = cyl.receiveShadow = true;
    g.add(cyl);
    [height/2, -height/2].forEach((py, i) => {
      const cap = new THREE.Mesh(new THREE.SphereGeometry(i === 0 ? rTop : rBot, 28, 18), mat.clone());
      cap.position.y = py; cap.castShadow = true; g.add(cap);
    });
    g.position.y = y;
    return g;
  }

  /* Shoulder */
  const shoulder = new THREE.Mesh(new THREE.SphereGeometry(0.168, 36, 24), S());
  shoulder.scale.set(1, 1.12, 0.90); shoulder.position.y = 0.74; shoulder.castShadow = true;
  group.add(shoulder);

  /* Deltoid bump */
  const delt = new THREE.Mesh(new THREE.SphereGeometry(0.138, 24, 18), S());
  delt.scale.set(1.08, 0.7, 0.72); delt.position.set(0.06, 0.68, 0.06); delt.castShadow = true;
  group.add(delt);

  /* Upper arm */
  const upperArm = limbSegment(0.142, 0.120, 0.62, 0.37, S());
  group.add(upperArm);

  /* Bicep */
  const bicep = new THREE.Mesh(new THREE.SphereGeometry(0.148, 28, 20), S());
  bicep.scale.set(0.88, 1.18, 0.76); bicep.position.set(0.018, 0.53, 0.07); bicep.castShadow = true;
  group.add(bicep);

  /* Tricep */
  const tricep = new THREE.Mesh(new THREE.SphereGeometry(0.128, 22, 16), S());
  tricep.scale.set(0.78, 1.4, 0.60); tricep.position.set(-0.02, 0.40, -0.07); tricep.castShadow = true;
  group.add(tricep);

  /* Elbow */
  const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.118, 30, 20), S(0x8c6545));
  elbow.scale.set(1, 0.86, 0.94); elbow.castShadow = true;
  group.add(elbow);

  /* Forearm */
  const forearm = limbSegment(0.110, 0.080, 0.60, -0.31, S());
  group.add(forearm);

  /* Extensor bulge */
  const ext = new THREE.Mesh(new THREE.SphereGeometry(0.100, 20, 14), S());
  ext.scale.set(0.82, 1.42, 0.68); ext.position.set(-0.012, -0.19, -0.045); ext.castShadow = true;
  group.add(ext);

  /* Wrist */
  const wrist = new THREE.Mesh(new THREE.SphereGeometry(0.078, 28, 18), S(0x8c6545));
  wrist.scale.set(1.08, 0.78, 0.86); wrist.position.y = -0.615; wrist.castShadow = true;
  group.add(wrist);

  /* Palm */
  const palm = new THREE.Mesh(new THREE.SphereGeometry(0.092, 28, 20), S());
  palm.scale.set(1.52, 1.92, 0.70); palm.position.y = -0.778; palm.castShadow = true;
  group.add(palm);

  /* Fingers */
  function finger(rz, len, x) {
    const fg = new THREE.Group();
    const f = new THREE.Mesh(new THREE.CapsuleGeometry(0.015, len, 8, 14), S(0x8c6848));
    f.castShadow = true; fg.add(f);
    fg.rotation.z = rz; fg.position.set(x, -0.92 - len/2, 0);
    return fg;
  }
  [[-0.09, 0.100, -0.056], [-0.022, 0.122, -0.018], [0.022, 0.112, 0.018], [0.09, 0.090, 0.056]].forEach(([rz,len,x]) => group.add(finger(rz,len,x)));

  /* Thumb */
  const thumb = new THREE.Group();
  const tf = new THREE.Mesh(new THREE.CapsuleGeometry(0.018, 0.076, 8, 10), S(0x8c6848));
  tf.castShadow = true; thumb.add(tf);
  thumb.rotation.set(-0.28, 0, -0.92); thumb.position.set(-0.102, -0.772, 0.028);
  group.add(thumb);

  /* ── TATTOO TEXTURE ─────────────────────────────────────────
     Render at 4096 × 4096 for sharp ink lines on high-DPI.
     ─────────────────────────────────────────────────────────── */
  const texSize = 1024;
  const tc = document.createElement('canvas');
  tc.width = tc.height = texSize;
  const ctx = tc.getContext('2d');
  ctx.clearRect(0, 0, texSize, texSize);

  [drawBlackGrey, drawGeometric, drawPortrait, drawDotwork][tattooStyle % 4](ctx, texSize);

  const tattooTex = new THREE.CanvasTexture(tc);
  tattooTex.anisotropy = renderer.capabilities.getMaxAnisotropy();

  /* Normal-map baked from tattoo ink variation */
  const normCanvas = document.createElement('canvas');
  normCanvas.width = normCanvas.height = texSize;
  const nc = normCanvas.getContext('2d');
  nc.drawImage(tc, 0, 0);
  const normTex = new THREE.CanvasTexture(normCanvas);

  /* Roughness variation: ink is slightly smoother than skin */
  const roughCanvas = document.createElement('canvas');
  roughCanvas.width = roughCanvas.height = texSize;
  const rc = roughCanvas.getContext('2d');
  rc.fillStyle = '#b0b0b0';  // base roughness ~0.69
  rc.fillRect(0, 0, texSize, texSize);
  rc.drawImage(tc, 0, 0);
  const roughTex = new THREE.CanvasTexture(roughCanvas);

  const tattooMat = new THREE.MeshPhysicalMaterial({
    map:            tattooTex,
    transparent:    true,
    alphaTest:      0.015,
    roughness:      0.60,
    metalness:      0.0,
    depthWrite:     false,
    side:           THREE.FrontSide,
    /* ink has slight specular from skin oils */
    specularIntensity: 0.3,
    specularColor:  new THREE.Color(0xffe0c0),
  });

  /* Wrap tattoo cylinder slightly proud of skin */
  const tattooGeo = new THREE.CylinderGeometry(0.114, 0.083, 0.56, 40, 1, true);
  const tattoo = new THREE.Mesh(tattooGeo, tattooMat);
  tattoo.position.y = -0.31;
  tattoo.renderOrder = 1;
  group.add(tattoo);

  group.rotation.x = 0.16;
  group.rotation.z = 0.05;
  return group;
}

/* ══════════════════════════════════════════════════════════════
   TATTOO DRAWING — 4K quality
   ══════════════════════════════════════════════════════════════ */

function drawBlackGrey(ctx, s) {
  /* Skull + roses B&G sleeve */
  const grd = ctx.createLinearGradient(0, 0, s*0.3, s);
  grd.addColorStop(0,   'rgba(14,10,14,0.82)');
  grd.addColorStop(0.4, 'rgba(28,18,24,0.65)');
  grd.addColorStop(1,   'rgba(8,6,8,0.78)');
  ctx.fillStyle = grd; ctx.fillRect(0, 0, s, s);

  /* Skull cranium */
  const cr = ctx.createRadialGradient(s*.50, s*.25, s*.02, s*.50, s*.25, s*.17);
  cr.addColorStop(0,   'rgba(240,230,218,0.96)');
  cr.addColorStop(0.55,'rgba(210,195,178,0.88)');
  cr.addColorStop(0.85,'rgba(160,142,118,0.60)');
  cr.addColorStop(1,   'rgba(80,65,50,0.0)');
  ctx.fillStyle = cr;
  ctx.beginPath(); ctx.ellipse(s*.50, s*.25, s*.145, s*.175, 0, 0, Math.PI*2); ctx.fill();

  /* Skull highlight */
  ctx.fillStyle = 'rgba(255,250,242,0.72)';
  ctx.beginPath(); ctx.ellipse(s*.465, s*.20, s*.048, s*.055, -0.35, 0, Math.PI*2); ctx.fill();

  /* Cheekbone shadow */
  ctx.fillStyle = 'rgba(30,20,30,0.35)';
  ctx.beginPath(); ctx.ellipse(s*.44, s*.31, s*.06, s*.035, 0.3, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(s*.56, s*.31, s*.06, s*.035, -0.3, 0, Math.PI*2); ctx.fill();

  /* Eye sockets */
  [s*.435, s*.565].forEach(ex => {
    const eg = ctx.createRadialGradient(ex, s*.27, 0, ex, s*.27, s*.042);
    eg.addColorStop(0, 'rgba(4,2,6,1)'); eg.addColorStop(1, 'rgba(10,6,12,0.5)');
    ctx.fillStyle = eg;
    ctx.beginPath(); ctx.ellipse(ex, s*.27, s*.040, s*.034, 0, 0, Math.PI*2); ctx.fill();
  });

  /* Nasal cavity */
  ctx.fillStyle = 'rgba(8,4,10,0.90)';
  ctx.beginPath(); ctx.moveTo(s*.500, s*.31); ctx.lineTo(s*.468, s*.345); ctx.lineTo(s*.532, s*.345); ctx.closePath(); ctx.fill();

  /* Teeth */
  ctx.strokeStyle = 'rgba(18,12,20,0.88)'; ctx.lineWidth = s*.003;
  for (let t = 0; t < 6; t++) {
    const tx = s*.43 + t*s*.025;
    ctx.fillStyle = 'rgba(220,208,192,0.88)';
    ctx.beginPath(); ctx.roundRect(tx, s*.365, s*.020, s*.030, s*.003); ctx.fill(); ctx.stroke();
  }

  /* Crack lines */
  ctx.strokeStyle = 'rgba(30,20,28,0.65)'; ctx.lineWidth = s*.003;
  [[s*.50,s*.10, s*.47,s*.22],[s*.50,s*.10, s*.54,s*.19],[s*.50,s*.10, s*.50,s*.06]].forEach(([x1,y1,x2,y2]) => {
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  });

  /* Roses */
  drawRose(ctx, s*.18, s*.58, s*.11, s);
  drawRose(ctx, s*.82, s*.58, s*.10, s);
  drawRose(ctx, s*.50, s*.78, s*.12, s);
  drawRose(ctx, s*.32, s*.45, s*.075, s);
  drawRose(ctx, s*.68, s*.45, s*.075, s);

  /* Flowing smoke lines */
  ctx.strokeStyle = 'rgba(185,165,148,0.40)'; ctx.lineWidth = s*.003;
  for (let i = 0; i < 14; i++) {
    ctx.beginPath();
    ctx.moveTo(Math.random()*s, 0);
    const c1x = Math.random()*s, c2x = Math.random()*s;
    ctx.bezierCurveTo(c1x, s*.25+Math.random()*s*.15, c2x, s*.6+Math.random()*s*.15, Math.random()*s, s);
    ctx.stroke();
  }

  /* Fine stipple shading */
  for (let i = 0; i < 3500; i++) {
    const x = Math.random()*s, y = Math.random()*s;
    ctx.fillStyle = `rgba(6,4,8,${0.03 + Math.random()*0.06})`;
    ctx.beginPath(); ctx.arc(x, y, Math.random()*s*.002 + s*.0003, 0, Math.PI*2); ctx.fill();
  }
}

function drawRose(ctx, cx, cy, r, s) {
  ctx.save(); ctx.translate(cx, cy);
  /* Outer petals */
  for (let i = 0; i < 16; i++) {
    const a  = (i/16)*Math.PI*2;
    const pr = r*(0.5 + 0.28*Math.sin(i*1.9 + 0.6));
    const lum = 15 + i*6;
    ctx.fillStyle = `rgba(${lum},${Math.max(0,lum-8)},${Math.max(0,lum-4)},${0.80 - i*0.022})`;
    ctx.beginPath();
    ctx.ellipse(Math.cos(a)*r*.40, Math.sin(a)*r*.40, pr*.58, pr*.34, a, 0, Math.PI*2);
    ctx.fill();
  }
  /* Inner petal layer */
  for (let i = 0; i < 10; i++) {
    const a = (i/10)*Math.PI*2 + 0.3;
    ctx.fillStyle = `rgba(${50+i*8},${35+i*5},${40+i*5},0.70)`;
    ctx.beginPath();
    ctx.ellipse(Math.cos(a)*r*.22, Math.sin(a)*r*.22, r*.22, r*.14, a, 0, Math.PI*2);
    ctx.fill();
  }
  /* Center */
  const cg = ctx.createRadialGradient(0,0,0,0,0,r*.14);
  cg.addColorStop(0,'rgba(8,5,8,0.98)'); cg.addColorStop(1,'rgba(18,12,18,0.5)');
  ctx.fillStyle = cg; ctx.beginPath(); ctx.arc(0,0,r*.16,0,Math.PI*2); ctx.fill();
  /* Highlight */
  ctx.fillStyle = 'rgba(255,240,220,0.18)';
  ctx.beginPath(); ctx.ellipse(-r*.04,-r*.05,r*.06,r*.04,-0.5,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawGeometric(ctx, s) {
  ctx.fillStyle = 'rgba(5,4,7,0.72)'; ctx.fillRect(0, 0, s, s);
  const cx = s*.50, cy = s*.36;

  /* Outer decorative rings */
  [s*.42, s*.36, s*.30, s*.22, s*.14].forEach((r, ri) => {
    const segs = (ri + 4) * 8;
    ctx.strokeStyle = `rgba(225,212,195,${0.90 - ri*0.10})`;
    ctx.lineWidth = ri === 0 ? s*.0035 : ri === 1 ? s*.0018 : s*.0010;
    ctx.beginPath();
    for (let i = 0; i <= segs; i++) {
      const a = (i/segs)*Math.PI*2;
      i === 0 ? ctx.moveTo(cx+Math.cos(a)*r, cy+Math.sin(a)*r)
              : ctx.lineTo(cx+Math.cos(a)*r, cy+Math.sin(a)*r);
    }
    ctx.closePath(); ctx.stroke();
  });

  /* Six-fold symmetry lines */
  for (let i = 0; i < 6; i++) {
    const a = (i/6)*Math.PI*2 - Math.PI/6;
    ctx.strokeStyle = 'rgba(210,195,175,0.72)'; ctx.lineWidth = s*.0014;
    ctx.beginPath(); ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(a)*s*.42, cy + Math.sin(a)*s*.42); ctx.stroke();
    /* Diamond nodes */
    [s*.14, s*.24, s*.34].forEach(d => {
      const bx = cx+Math.cos(a)*d, by = cy+Math.sin(a)*d;
      ctx.fillStyle = 'rgba(218,202,180,0.78)';
      ctx.beginPath();
      ctx.moveTo(bx, by-s*.020); ctx.lineTo(bx+s*.014, by);
      ctx.lineTo(bx, by+s*.020); ctx.lineTo(bx-s*.014, by);
      ctx.closePath(); ctx.fill();
    });
  }

  /* Flower of life inner circles */
  for (let i = 0; i < 6; i++) {
    const a = (i/6)*Math.PI*2;
    const fx = cx+Math.cos(a)*s*.12, fy = cy+Math.sin(a)*s*.12;
    ctx.strokeStyle = 'rgba(200,185,165,0.55)'; ctx.lineWidth = s*.0010;
    ctx.beginPath(); ctx.arc(fx, fy, s*.12, 0, Math.PI*2); ctx.stroke();
  }

  /* Interlocking triangles (Star of David) */
  [[s*.50,s*.01, s*.09,s*.44, s*.91,s*.44],
   [s*.50,s*.44, s*.09,s*.01, s*.91,s*.01]].forEach(([x1,y1,x2,y2,x3,y3]) => {
    ctx.strokeStyle = 'rgba(245,235,218,0.52)'; ctx.lineWidth = s*.0018;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.closePath(); ctx.stroke();
  });

  /* Bottom chevron pattern */
  for (let row = 0; row < 12; row++) {
    const y = s*.52 + row*s*.040;
    ctx.strokeStyle = `rgba(188,172,152,${0.60 - row*0.025})`; ctx.lineWidth = s*.0009;
    ctx.beginPath();
    for (let xi = 0; xi <= 24; xi++) {
      const xp = (xi/24)*s;
      const yp = y + Math.sin((xi/24)*Math.PI*6)*s*.009;
      xi === 0 ? ctx.moveTo(xp,yp) : ctx.lineTo(xp,yp);
    }
    ctx.stroke();
  }

  /* Center orb fill */
  const og = ctx.createRadialGradient(cx,cy,0,cx,cy,s*.08);
  og.addColorStop(0,'rgba(240,225,202,0.65)'); og.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle = og; ctx.beginPath(); ctx.arc(cx,cy,s*.08,0,Math.PI*2); ctx.fill();
}

function drawPortrait(ctx, s) {
  ctx.fillStyle = 'rgba(7,5,9,0.62)'; ctx.fillRect(0, 0, s, s);

  /* Face oval with SSS-like radial gradient */
  const fg = ctx.createRadialGradient(s*.50, s*.31, s*.01, s*.50, s*.31, s*.24);
  fg.addColorStop(0,   'rgba(238,222,202,0.96)');
  fg.addColorStop(0.50,'rgba(205,182,158,0.84)');
  fg.addColorStop(0.80,'rgba(158,128,98,0.50)');
  fg.addColorStop(1,   'rgba(80,55,35,0.0)');
  ctx.fillStyle = fg;
  ctx.beginPath(); ctx.ellipse(s*.50, s*.31, s*.19, s*.245, 0, 0, Math.PI*2); ctx.fill();

  /* Jawline shadow */
  ctx.fillStyle = 'rgba(25,15,28,0.30)';
  ctx.beginPath(); ctx.ellipse(s*.50, s*.46, s*.12, s*.045, 0, 0, Math.PI*2); ctx.fill();

  /* Calavera floral eyes */
  [[s*.40,s*.28],[s*.60,s*.28]].forEach(([ex,ey]) => {
    /* Petals */
    for (let p = 0; p < 8; p++) {
      const a = (p/8)*Math.PI*2;
      ctx.strokeStyle = 'rgba(12,8,16,0.92)'; ctx.lineWidth = s*.003;
      ctx.beginPath();
      ctx.ellipse(ex+Math.cos(a)*s*.038, ey+Math.sin(a)*s*.038, s*.022, s*.012, a, 0, Math.PI*2);
      ctx.stroke();
    }
    /* Pupil */
    ctx.fillStyle = 'rgba(6,3,8,0.95)';
    ctx.beginPath(); ctx.arc(ex, ey, s*.010, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,245,230,0.55)';
    ctx.beginPath(); ctx.arc(ex-s*.004, ey-s*.004, s*.004, 0, Math.PI*2); ctx.fill();
  });

  /* Nose bridge shading */
  ctx.fillStyle = 'rgba(20,12,24,0.60)';
  ctx.beginPath(); ctx.moveTo(s*.50,s*.325); ctx.lineTo(s*.466,s*.375); ctx.lineTo(s*.534,s*.375); ctx.closePath(); ctx.fill();

  /* Mouth — cupid's bow */
  const mg = ctx.createLinearGradient(s*.40, s*.40, s*.60, s*.40);
  mg.addColorStop(0,'rgba(18,10,20,0)'); mg.addColorStop(0.5,'rgba(18,10,20,0.88)'); mg.addColorStop(1,'rgba(18,10,20,0)');
  ctx.strokeStyle = mg; ctx.lineWidth = s*.004;
  ctx.beginPath(); ctx.arc(s*.50, s*.415, s*.088, Math.PI*.06, Math.PI*.94); ctx.stroke();

  /* Stitches */
  for (let t = 0; t < 7; t++) {
    const a = Math.PI*.10 + t*(Math.PI*.76/6);
    const px = s*.50+Math.cos(a)*s*.088, py = s*.415+Math.sin(a)*s*.088;
    ctx.strokeStyle = 'rgba(10,6,12,0.88)'; ctx.lineWidth = s*.003;
    ctx.beginPath(); ctx.moveTo(px, py-s*.013); ctx.lineTo(px, py+s*.013); ctx.stroke();
  }

  /* Floral halo / crown */
  ctx.strokeStyle = 'rgba(195,178,155,0.50)'; ctx.lineWidth = s*.0012;
  for (let i = 0; i < 22; i++) {
    const a = (i/22)*Math.PI*2;
    ctx.beginPath();
    ctx.ellipse(s*.50+Math.cos(a)*s*.24, s*.31+Math.sin(a)*s*.22, s*.038, s*.022, a, 0, Math.PI*2);
    ctx.stroke();
  }

  /* Neck / lower motif bands */
  for (let b = 0; b < 6; b++) {
    const alpha = 0.52 - b*.04;
    ctx.fillStyle = `rgba(10,7,12,${alpha})`;
    ctx.fillRect(0, s*(.60 + b*.068), s, s*.025);
    ctx.fillStyle = `rgba(205,182,155,0.20)`;
    ctx.fillRect(s*.04, s*(.614 + b*.068), s*.92, s*.010);
  }

  /* Fine cross-hatch shading on face */
  ctx.strokeStyle = 'rgba(12,8,14,0.08)'; ctx.lineWidth = s*.0007;
  for (let i = 0; i < 40; i++) {
    const y = s*.12 + i*s*.010;
    ctx.beginPath();
    ctx.moveTo(s*.30 + Math.sin(i*.4)*s*.04, y);
    ctx.lineTo(s*.70 - Math.sin(i*.4)*s*.04, y);
    ctx.stroke();
  }
}

function drawDotwork(ctx, s) {
  ctx.fillStyle = 'rgba(5,4,7,0.65)'; ctx.fillRect(0, 0, s, s);
  const cx = s*.50, cy = s*.34;

  /* Large lotus petals */
  for (let i = 0; i < 12; i++) {
    const a = (i/12)*Math.PI*2 - Math.PI/12;
    ctx.save(); ctx.translate(cx, cy); ctx.rotate(a);
    const pg = ctx.createLinearGradient(0,0,0,-s*.22);
    pg.addColorStop(0,'rgba(218,202,178,0.35)'); pg.addColorStop(1,'rgba(218,202,178,0.0)');
    ctx.fillStyle = pg;
    ctx.beginPath(); ctx.ellipse(0,-s*.16, s*.044, s*.150, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(200,183,160,0.65)'; ctx.lineWidth = s*.0011;
    ctx.stroke();
    ctx.restore();
  }

  /* Dense stipple cloud */
  function stipple(x, y, r, n, alpha) {
    for (let i = 0; i < n; i++) {
      const a2 = Math.random()*Math.PI*2, d = Math.random()*r;
      const sz = Math.random()*s*.0022 + s*.0004;
      ctx.fillStyle = `rgba(214,198,175,${alpha*(0.45+Math.random()*.55)})`;
      ctx.beginPath(); ctx.arc(x+Math.cos(a2)*d, y+Math.sin(a2)*d, sz, 0, Math.PI*2); ctx.fill();
    }
  }
  stipple(cx, cy, s*.44, 4200, 0.58);

  /* Concentric dot rings */
  for (let ring = 1; ring <= 7; ring++) {
    const r = ring*s*.062;
    const count = ring*16;
    for (let d = 0; d < count; d++) {
      const a = (d/count)*Math.PI*2;
      const sz = (ring < 3 ? s*.002 : s*.0014) * (0.7 + Math.random()*.6);
      ctx.fillStyle = `rgba(212,196,172,${0.75-ring*.07})`;
      ctx.beginPath(); ctx.arc(cx+Math.cos(a)*r, cy+Math.sin(a)*r, sz, 0, Math.PI*2); ctx.fill();
    }
  }

  /* Stem */
  ctx.strokeStyle = 'rgba(192,176,152,0.70)'; ctx.lineWidth = s*.0018;
  ctx.beginPath(); ctx.moveTo(cx, s*.46); ctx.bezierCurveTo(cx-s*.02, s*.62, cx+s*.02, s*.78, cx, s*.96); ctx.stroke();

  /* Leaves on stem */
  [[s*.50,s*.57, -24, -32], [s*.50,s*.68, 22, 30], [s*.50,s*.80, -18, -26]].forEach(([x,y,lx,ly]) => {
    ctx.strokeStyle = 'rgba(195,178,155,0.65)'; ctx.lineWidth = s*.0013;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x+lx, y-10, x+lx, y+ly); ctx.stroke();
    stipple(x+lx/2, y+ly/3, s*.07, 280, 0.48);
  });

  /* Inner mandala fill glow */
  const ig = ctx.createRadialGradient(cx,cy,0,cx,cy,s*.08);
  ig.addColorStop(0,'rgba(235,215,185,0.55)'); ig.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle = ig; ctx.beginPath(); ctx.arc(cx,cy,s*.08,0,Math.PI*2); ctx.fill();
}

/* ── State ───────────────────────────────────────────────────── */
let currentModel = null;
let autoRotate   = true;
let clock        = new THREE.Clock();
let introT       = 0;   // camera intro dolly progress 0→1

/* ── Resize ──────────────────────────────────────────────────── */
function resize() {
  const w = wrap.clientWidth, h = wrap.clientHeight;
  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
new ResizeObserver(resize).observe(wrap);

/* ── Load piece ──────────────────────────────────────────────── */
function loadPiece(modelPath, title, isPlaceholder, tattooIdx) {
  if (currentModel) { scene.remove(currentModel); currentModel = null; }
  pieceNameEl.textContent = title;
  introT = 0;

  const idx = parseInt(tattooIdx ?? 0);

  if (isPlaceholder) {
    placeholderEl.style.display = 'flex';
    uiEl.style.opacity = '1';
    loadingEl.style.display = 'none';
    const arm = buildArm(idx);
    currentModel = arm;
    scene.add(arm);
    return;
  }

  placeholderEl.style.display = 'none';
  uiEl.style.opacity = '1';
  loadingEl.style.display = 'flex';

  gltfLoader.load(modelPath,
    (data) => {
      loadingEl.style.display = 'none';
      const model = data.scene;
      const box   = new THREE.Box3().setFromObject(model);
      const size  = box.getSize(new THREE.Vector3());
      const center= box.getCenter(new THREE.Vector3());
      const scale = 1.6 / Math.max(size.x, size.y, size.z);
      model.scale.setScalar(scale);
      model.position.sub(center.multiplyScalar(scale));
      model.traverse(c => {
        if (c.isMesh) {
          c.castShadow = c.receiveShadow = true;
          if (c.material) {
            c.material.roughness  = Math.max(c.material.roughness ?? 0.7, 0.45);
            c.material.envMapIntensity = 1.2;
          }
        }
      });
      currentModel = model;
      scene.add(model);
      controls.reset();
    },
    null,
    () => {
      loadingEl.style.display = 'none';
      placeholderEl.style.display = 'flex';
      const arm = buildArm(idx);
      currentModel = arm; scene.add(arm);
    }
  );
}

/* ── Tabs ────────────────────────────────────────────────────── */
tabs.forEach((tab, idx) => {
  tab.dataset.idx = idx;
  tab.addEventListener('click', () => {
    tabs.forEach(t => { t.classList.remove('s3d-tab--active'); t.setAttribute('aria-selected','false'); });
    tab.classList.add('s3d-tab--active'); tab.setAttribute('aria-selected','true');
    loadPiece(tab.dataset.model, tab.querySelector('.s3d-tab-title').textContent, tab.dataset.placeholder==='true', tab.dataset.idx);
  });
});

btnReset.addEventListener('click', () => { controls.reset(); camera.position.set(0,0.25,3.2); introT=0; });
btnAuto.addEventListener('click', () => {
  autoRotate = !autoRotate;
  controls.autoRotate = autoRotate;
  btnAuto.classList.toggle('s3d-btn--active', autoRotate);
});
btnFS.addEventListener('click', () => {
  if (!document.fullscreenElement) wrap.requestFullscreen?.().catch(()=>{});
  else document.exitFullscreen?.();
});

/* ── Render loop ─────────────────────────────────────────────── */
(function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const t  = clock.elapsedTime;

  /* Camera intro dolly (cinematic pull-back on load) */
  if (introT < 1) {
    introT = Math.min(1, introT + dt * 0.55);
    const ease = 1 - Math.pow(1 - introT, 3);
    camera.position.lerp(new THREE.Vector3(0, 0.25, 3.2), ease * 0.06 + 0.001);
  }

  /* Floating dust drift */
  const dp = dustGeo.attributes.position.array;
  for (let i = 0; i < dustCount; i++) {
    dp[i*3+1] += Math.sin(t * 0.22 + i * 0.8) * 0.00018;
    dp[i*3]   += Math.cos(t * 0.17 + i * 1.2) * 0.00012;
  }
  dustGeo.attributes.position.needsUpdate = true;

  /* Breathing rim light — subtle warm pulse */
  rim.intensity = 1.4 + Math.sin(t * 0.6) * 0.25;

  /* Flare opacity breath */
  flareMat.opacity = 0.28 + Math.sin(t * 0.4) * 0.10;

  /* Hemi sky colour slow shift (studio environment cycle) */
  const hc = (Math.sin(t * 0.08) + 1) * 0.5;
  hemi.color.setHSL(0.08 + hc * 0.04, 0.6, 0.82);

  controls.update();

  /* Main scene */
  renderer.autoClear = true;
  renderer.render(scene, camera);

  /* Vignette overlay */
  renderer.autoClear = false;
  renderer.clearDepth();
  renderer.render(vigScene, vigCam);
})();

/* ── Boot ────────────────────────────────────────────────────── */
resize();
if (tabs[0]) {
  tabs[0].dataset.idx = '0';
  loadPiece(tabs[0].dataset.model, tabs[0].querySelector('.s3d-tab-title').textContent, tabs[0].dataset.placeholder==='true', 0);
  btnAuto.classList.add('s3d-btn--active');
}
</script>

<style>
  /* ── Artist hero ──────────────────────────────────── */
  .artist-hero {
    position: relative;
    min-height: 60vh;
    display: flex;
    align-items: flex-end;
    padding-bottom: 52px;
  }
  .artist-hero-bg { position: absolute; inset: 0; overflow: hidden; }
  .artist-hero-bg img { width: 100%; height: 100%; object-fit: cover; object-position: center; filter: brightness(0.42); }
  .artist-hero-overlay { position: absolute; inset: 0; background: linear-gradient(to top, rgba(7,6,8,0.97) 0%, rgba(7,6,8,0.25) 65%, transparent 100%); }
  .artist-hero-content { position: relative; z-index: 1; }
  .artist-meta h1 { margin: 8px 0 4px; }
  .artist-specialty { font-family: var(--font-heading); font-style: italic; font-size: 18px; color: var(--gold-lt); margin-bottom: 4px; }
  .artist-handle { font-size: 13px; color: var(--muted); margin-bottom: 20px; }
  .artist-handle a { color: var(--gold); }
  .artist-ctas { display: flex; gap: 10px; flex-wrap: wrap; }

  /* ── 3D Section ───────────────────────────────────── */
  .section-3d {
    background: #050405;
    padding: 72px 0 64px;
  }
  .container-3d {
    width: 100%;
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 20px;
  }
  .gold-text { color: var(--gold); }

  .s3d-header { margin-bottom: 36px; }
  .s3d-lead { max-width: 48ch; margin-top: 12px; }

  .s3d-controls-hint {
    display: flex;
    gap: 20px;
    margin-top: 16px;
    flex-wrap: wrap;
  }
  .s3d-controls-hint span {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.8px;
    color: var(--muted2);
    text-transform: uppercase;
  }
  .s3d-controls-hint svg { color: var(--gold); flex-shrink: 0; }

  /* ── Piece tabs ───────────────────────────────────── */
  .s3d-tabs {
    display: flex;
    gap: 10px;
    overflow-x: auto;
    scrollbar-width: none;
    padding-bottom: 4px;
    margin-bottom: 20px;
  }
  .s3d-tabs::-webkit-scrollbar { display: none; }

  .s3d-tab {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 14px 10px 10px;
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    transition: border-color 0.18s, background 0.18s, transform 0.15s;
    flex-shrink: 0;
    max-width: 220px;
    text-align: left;
    -webkit-tap-highlight-color: transparent;
  }
  .s3d-tab:hover { border-color: rgba(185,138,55,0.35); background: rgba(185,138,55,0.04); }
  .s3d-tab--active {
    border-color: var(--gold);
    background: rgba(185,138,55,0.08);
    box-shadow: 0 0 0 1px rgba(185,138,55,0.2);
  }

  .s3d-tab-thumb {
    position: relative;
    width: 52px; height: 52px;
    border-radius: 6px;
    overflow: hidden;
    flex-shrink: 0;
  }
  .s3d-tab-thumb img { width: 100%; height: 100%; object-fit: cover; }
  .s3d-tab-badge {
    position: absolute; bottom: 2px; right: 2px;
    display: flex; align-items: center; gap: 2px;
    padding: 1px 5px;
    background: var(--gold);
    color: #0a0608;
    font-size: 7px;
    font-weight: 800;
    letter-spacing: 0.5px;
    border-radius: 3px;
  }
  .s3d-tab-info { display: flex; flex-direction: column; gap: 3px; min-width: 0; }
  .s3d-tab-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .s3d-tab-style {
    font-size: 10px;
    color: var(--muted2);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* ── Viewer wrap ──────────────────────────────────── */
  .s3d-viewer-wrap {
    position: relative;
    width: 100%;
    height: min(540px, 70vw);
    min-height: 320px;
    border-radius: 12px;
    overflow: hidden;
    background: #0e0c0d;
    border: 1px solid var(--border);
    box-shadow: 0 24px 80px rgba(0,0,0,0.7);
  }

  .s3d-canvas {
    position: absolute;
    inset: 0;
    width: 100% !important;
    height: 100% !important;
    display: block;
    touch-action: none;
  }

  /* Loading overlay */
  .s3d-loading {
    position: absolute; inset: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 14px;
    background: rgba(14,12,13,0.85);
    z-index: 10;
    pointer-events: none;
  }
  .s3d-loading p { font-size: 12px; color: var(--muted); letter-spacing: 1px; text-transform: uppercase; }
  .s3d-spinner {
    width: 36px; height: 36px;
    border: 2px solid rgba(185,138,55,0.2);
    border-top-color: var(--gold);
    border-radius: 50%;
    animation: spin 0.75s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Preview badge — bottom bar, non-intrusive */
  .s3d-placeholder {
    position: absolute;
    bottom: 12px; left: 12px;
    display: none;
    z-index: 8;
    pointer-events: none;
  }
  .s3d-placeholder-inner {
    background: rgba(14,12,13,0.78);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(185,138,55,0.30);
    border-radius: 6px;
    padding: 6px 12px;
  }
  .s3d-placeholder-title {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 10px;
    font-weight: 700;
    color: var(--gold);
    letter-spacing: 1px;
    text-transform: uppercase;
    white-space: nowrap;
  }

  /* Viewer UI (top right) */
  .s3d-ui {
    position: absolute;
    top: 14px; right: 14px;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 8px;
    z-index: 9;
    transition: opacity 0.3s;
  }
  .s3d-piece-name {
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--gold);
    background: rgba(14,12,13,0.7);
    padding: 4px 10px;
    border-radius: 4px;
    backdrop-filter: blur(8px);
  }
  .s3d-actions { display: flex; gap: 6px; }
  .s3d-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px; height: 36px;
    background: rgba(14,12,13,0.75);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 6px;
    color: var(--muted);
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s, color 0.15s;
    -webkit-tap-highlight-color: transparent;
  }
  .s3d-btn:hover { background: rgba(185,138,55,0.15); border-color: var(--gold); color: var(--gold); }
  .s3d-btn--active { background: rgba(185,138,55,0.18); border-color: var(--gold); color: var(--gold); }

  /* ── CTA under viewer ─────────────────────────────── */
  .s3d-cta {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 24px;
  }
  .s3d-cta-text {
    font-size: 14px;
    color: var(--muted);
    flex: 1;
    min-width: 200px;
  }

  /* ── Bio / Gallery / CTA / Aftercare (same as before) */
  .bio-grid { display: grid; gap: 40px; }
  @media (min-width: 760px) { .bio-grid { grid-template-columns: 1fr 2fr; align-items: start; } }

  .gallery-section { background: #000; padding: 64px 0 0; }
  .artist-gallery-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-auto-rows: 220px;
    gap: 3px;
    margin-top: 24px;
  }
  .ag-item { position: relative; overflow: hidden; display: block; background: var(--dark); }
  .ag-item img { width: 100%; height: 100%; object-fit: cover; transition: transform 0.6s, filter 0.4s; filter: brightness(0.85); }
  .ag-item:hover img { transform: scale(1.07); filter: brightness(0.65); }
  .ag-item--tall { grid-row: span 2; }
  .ag-overlay { position: absolute; inset: 0; display: flex; align-items: flex-end; justify-content: flex-end; padding: 12px; transition: background 0.3s; }
  .ag-overlay span { font-size: 16px; color: var(--gold); opacity: 0; transform: translateY(6px); transition: opacity 0.2s, transform 0.2s; }
  .ag-item:hover .ag-overlay { background: rgba(185,138,55,0.08); }
  .ag-item:hover .ag-overlay span { opacity: 1; transform: translateY(0); }
  @media (max-width: 640px) {
    .artist-gallery-grid { grid-template-columns: repeat(2, 1fr); grid-auto-rows: 160px; }
    .ag-item--tall { grid-row: span 1; }
  }

  .artist-cta-block { display: grid; gap: 28px; padding: 36px; background: var(--surface); }
  @media (min-width: 760px) { .artist-cta-block { grid-template-columns: 1fr auto; align-items: center; } }
  .artist-cta-btns { display: flex; flex-direction: column; gap: 10px; min-width: 180px; }
  .artist-cta-btns .btn { justify-content: center; }

  .aftercare-section { background: var(--dark); }
  .aftercare-grid { display: grid; gap: 16px; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); }
  .aftercare-num { font-family: var(--font-display); font-size: 48px; color: var(--border-gold); line-height: 1; margin-bottom: 8px; }
  .aftercare-card .h3 { margin-bottom: 8px; font-size: 20px; }
  .aftercare-card p { font-size: 14px; color: var(--muted); line-height: 1.65; }

  /* ── Fullscreen ─────────────────────────────────────── */
  .s3d-viewer-wrap:fullscreen {
    border-radius: 0;
    height: 100vh;
    width: 100vw;
    max-height: none;
  }
  .s3d-viewer-wrap:-webkit-full-screen {
    border-radius: 0;
    height: 100vh;
    width: 100vw;
  }

  /* ── Mobile ─────────────────────────────────────────── */
  @media (max-width: 480px) {
    .section-3d { padding: 48px 0 40px; }
    .s3d-viewer-wrap { height: 60vw; min-height: 260px; }
    .s3d-controls-hint { gap: 12px; }
    .s3d-controls-hint span { font-size: 9px; }
  }
</style>
